<?php

/**
 * Process Link Checker
 *
 * Process Link Checker is a module for ProcessWire CMS/CMF. When used together
 * with the Link Crawler class, the main feature of this module is providing a
 * GUI for viewing broken links and redirects affecting content of the site.
 * 
 * @todo consider making tabs configurable (status codes on redirects tab etc.)
 * @todo consider adding more widgets to the dashboard (domains, keywords, ...)
 *
 * @author Teppo Koivula <teppo.koivula@gmail.com>
 * @copyright Copyright (c) 2014-2016, Teppo Koivula
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 *
 */
class ProcessLinkChecker extends Process implements ConfigurableModule {

    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return array(
            'title' => __('Link Checker'),
            'summary' => __('Tool for automated link checking.'),
            'author' => 'Teppo Koivula',
            'version' => '0.9.9',
            'singular' => true,
            'autoload' => 'template=admin, name=module|' . self::PAGE_NAME,
            'permission' => 'link-checker',
            'permissions' => array(
                'link-checker' => 'Link Checker (access)',
                'link-checker-run' => 'Link Checker (run)',
            ),
            'icon' => 'link',
        ); 
    }

    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    static public function getDefaultData() {
        return array(
            'skipped_links' => array(),
            'cache_max_age' => '1 DAY',
            'selector' => 'status<8192, id!=2, has_parent!=2',
            'http_host_source' => 'manual',
            'http_host_protocol' => 'http',
            'http_host' => null,
            'log_level' => 1,
            'log_rotate' => 0,
            'log_on_screen' => false,
            'batch_size' => 100,
            'sleep_between_batches' => 1,
            'max_recursion_depth' => 3,
            'sleep_between_requests' => 1,
            'sleep_between_pages' => 0,
            'link_regex' => '/(?:href|src)=([\\\'"])([^#].*?)\g{-2}/i',
            'skipped_links_regex' => null,
            'http_request_method' => 'get_headers',
            'http_user_agent' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',
            'render_method' => 'render_fields',
        );
    }

    /**
     * Names of the database tables used by this module and the crawler
     * 
     */
    const TABLE_LINKS = 'link_checker_links';
    const TABLE_LINKS_PAGES = 'link_checker_links_pages';
    const TABLE_HISTORY = 'link_checker_history';

    /**
     * Name of admin page created and used by this module
     * 
     */
    const PAGE_NAME = 'link-checker';

    /**
     * Descriptive names for HTTP status codes
     * 
     */
    protected $status_codes = array(
        100 => 'Continue',
        101 => 'Switching Protocols',
        102 => 'Processing',
        200 => 'OK',
        201 => 'Created',
        202 => 'Accepted',
        203 => 'Non-Authoritative Information',
        204 => 'No Content',
        205 => 'Reset Content',
        206 => 'Partial Content',
        207 => 'Multi-Status',
        300 => 'Multiple Choices',
        301 => 'Moved Permanently',
        302 => 'Found',
        303 => 'See Other',
        304 => 'Not Modified',
        305 => 'Use Proxy',
        306 => 'Switch Proxy',
        307 => 'Temporary Redirect',
        308 => 'Permanent Redirect', // RFC 7238
        400 => 'Bad Request',
        401 => 'Unauthorized',
        402 => 'Payment Required',
        403 => 'Forbidden',
        404 => 'Not Found',
        405 => 'Method Not Allowed',
        406 => 'Not Acceptable',
        407 => 'Proxy Authentication Required',
        408 => 'Request Timeout',
        409 => 'Conflict',
        410 => 'Gone',
        411 => 'Length Required',
        412 => 'Precondition Failed',
        413 => 'Request Entity Too Large',
        414 => 'Request-URI Too Long',
        415 => 'Unsupported Media Type',
        416 => 'Requested Range Not Satisfiable',
        417 => 'Expectation Failed',
        418 => 'I\'m a teapot', // RFC 2324
        419 => 'Authentication Timeout',
        420 => 'Enhance Your Calm', // Twitter
        422 => 'Unprocessable Entity',
        423 => 'Locked',
        424 => 'Failed Dependency',
        425 => 'Unordered Collection',
        426 => 'Upgrade Required',
        429 => 'Too Many Requests', // RFC 6585
        449 => 'Retry With',
        450 => 'Blocked by Windows Parental Controls',
        500 => 'Internal Server Error',
        501 => 'Not Implemented',
        502 => 'Bad Gateway',
        503 => 'Service Unavailable',
        504 => 'Gateway Timeout',
        505 => 'HTTP Version Not Supported',
        506 => 'Variant Also Negotiates',
        507 => 'Insufficient Storage',
        509 => 'Bandwidth Limit Exceeded',
        510 => 'Not Extended',
    );
    
    /**
     * Placeholder for page object
     *
     */
    protected $process_page = null;
    
    /**
     * Known tables and related WHERE clauses
     * 
     */
    protected $tables = array(
        'broken-links' => 'links.skip = 0 AND (links.status IS NULL OR links.status >= 400)',
        'redirects' => 'links.skip = 0 AND links.status BETWEEN 300 AND 399 AND links.status NOT IN (302,304,307)',
        'skipped-links' => 'links.skip = 1',
    );

    /**
     * Instance of LinkCrawler
     *
     */
    protected $crawler = null;
    
    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     *
     */
    public function __construct() {
        foreach (self::getDefaultData() as $key => $value) {
            $this->$key = $value;
        }
    }

    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // merge default config settings (custom values overwrite defaults)
        $defaults = self::getDefaultData();
        $data = array_merge($defaults, $data);

        // clear cache?
        $cache_count = null;
        try {
            $cache_query = wire('database')->query("SELECT COUNT(*) FROM " . self::TABLE_LINKS . " WHERE skip = 0");
            $cache_count = (int) $cache_query->fetchColumn();
            if (wire('input')->post->_clear_cache) {
                wire('database')->query("
                    DELETE links, links_pages
                    FROM " . self::TABLE_LINKS . " links, " . self::TABLE_LINKS_PAGES . " links_pages 
                    WHERE links.skip = 0 AND links_pages.links_id = links.id
                ");
                wire('session')->message(sprintf(__("Cleared cache for %d links"), $cache_count));
                wire('session')->redirect($_SERVER['REQUEST_URI'], false);
            }
        } catch (Exception $e) {
            $field = wire('modules')->get('InputfieldMarkup');
            $field->contentClass = 'NoticeError';
            $field->markupText = __("Error: links table is currently unreachable, possibly due to a database issue.");
            $fields->add($field);
        }

        // selector for finding pages to check for broken links
        if (wire('modules')->isInstalled('InputfieldSelector')) {
            $field = wire('modules')->get('InputfieldSelector');
        } else {
            $field = wire('modules')->get('InputfieldText');
        }
        $field->name = "selector";
        $field->label = __("Selector");
        $field->icon = "search";
        $field->value = $data[$field->name];
        $field->description = __("Selector for finding pages to check for broken links.");
        $fields->add($field);

        // link settings
        $fieldset = wire('modules')->get('InputfieldFieldset');
        $fieldset->label = __("Links");
        $fieldset->icon = "link";
        $fields->add($fieldset);

        // link regex
        $field = wire('modules')->get('InputfieldText');
        $field->name = "link_regex";
        $field->label = __("Link regex");
        $field->required = true;
        $field->description = __("Used to identify checkable links from page content.");
        $field->notes = __("Use [PCRE](http://www.php.net/manual/en/pcre.pattern.php) syntax including delimiters and modifiers.")
                      . sprintf(" " . __("Default: %s."), $defaults['link_regex']);
        $field->pattern = '(^[^\w\s\\\]|_).*\1([imsxADSUXJu]*)$';
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // skipped links
        $field = wire('modules')->get('InputfieldTextarea');
        $field->name = "skipped_links";
        $field->label = __("Skipped links");
        $field->description = __("Links that should be skipped, one per line. Links pointing to admin area will always be skipped.");
        if ($data[$field->name]) $field->value = implode("\n", $data[$field->name]);
        $fieldset->add($field);

        // skipped links regex
        $field = wire('modules')->get('InputfieldTextarea');
        $field->name = "skipped_links_regex";
        $field->label = __("Skipped links regex");
        $field->description = __("Regex patterns identifying skipped links, one per line. Additionally all malformed links and links pointing to admin area will be skipped.");
        $field->notes = __("Use [PCRE](http://www.php.net/manual/en/pcre.pattern.php) syntax including delimiters and modifiers.");
        $field->pattern = '^(?:([^\w\s\\\]|_).*\1(?:[imsxADSUXJu]*)(?:\r\n|\n|\r|$))+$';
        if ($data[$field->name]) $field->value = implode("\n", $data[$field->name]);
        $fieldset->add($field);

        // default http host
        $field = wire('modules')->get('InputfieldRadios');
        $field->name = "http_host_source";
        $field->label = __("HTTP host for relative URLs");
        $field->description = __("Relative URLs need to be prefixed with HTTP host (such as http://localhost/) before they can be checked.");
        $field->addOptions(array(
            'manual' => __('Define manually'),
            'config' => __('Use $config->httpHost'),
        ));
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // default http host
        $field = wire('modules')->get('InputfieldRadios');
        $field->name = "http_host_protocol";
        $field->label = __("Protocol used for relative URLs");
        $field->description = __('When HTTP host is defined by $config->httpHost, protocol needs to be defined separately.');
        $field->addOptions(array(
            'http' => 'HTTP',
            'https' => 'HTTPS',
        ));
        $field->value = $data[$field->name];
        $field->showIf = "http_host_source=config";
        $fieldset->add($field);

        // default http host
        $field = wire('modules')->get('InputfieldURL');
        $field->name = "http_host";
        $field->label = __("Manually defined HTTP host");
        $field->description = __("Type in the full address of your site, including the http:// or https:// prefix.");
        $field->notes = __("If HTTP host is left blank, relative URLs won't be checked.");
        $field->value = $data[$field->name];
        $field->showIf = "http_host_source=manual";
        $fieldset->add($field);

        // conection settings
        $fieldset = wire('modules')->get('InputfieldFieldset');
        $fieldset->label = __("Connection");
        $fieldset->icon = "cloud";
        $fields->add($fieldset);

        // batch size
        $field = wire('modules')->get('InputfieldInteger');
        $field->name = "batch_size";
        $field->label = __("Batch size");
        $field->columnWidth = 50;
        $field->description = __("How many pages should be loaded into memory simultaneously?");
        $field->notes = __("Used to decrease memory usage during link crawling. Smaller batch size uses less memory but requires more database queries.");
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // sleep between batches
        $field = wire('modules')->get('InputfieldFloat');
        $field->name = "sleep_between_batches";
        $field->label = __("Sleep between batches");
        $field->columnWidth = 50;
        $field->description = __("For how long should the crawler sleep between each batch of pages, in seconds?");
        $field->notes = __("Used to decrease load both for local server (one making the requests) and the opposite end. Default value is one second.");
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // sleep between requests
        $field = wire('modules')->get('InputfieldFloat');
        $field->name = "sleep_between_requests";
        $field->label = __("Sleep between requests");
        $field->columnWidth = 50;
        $field->description = __("For how long should the crawler sleep between each request, in seconds?");
        $field->notes = __("Used to decrease load both for local server (one making the requests) and the opposite end. Default value is one second.");
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // sleep between pages
        $field = wire('modules')->get('InputfieldFloat');
        $field->name = "sleep_between_pages";
        $field->label = __("Sleep between pages");
        $field->columnWidth = 50;
        $field->description = __("For how long should the crawler sleep between each checked page, in seconds?");
        $field->notes = __("Used to decrease load both for local server (one making the requests) and the opposite end. Disabled by default.");
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // http request method
        $field = wire('modules')->get('InputfieldSelect');
        $field->name = "http_request_method";
        $field->label = __("HTTP request method");
        $field->notes = __("Default request method is get_headers().");
        $field->addOptions(array(
            'get_headers' => 'get_headers()',
        ));
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // link regex
        $field = wire('modules')->get('InputfieldText');
        $field->name = "http_user_agent";
        $field->label = __("User agent");
        $field->required = false;
        $field->description = __("User-Agent header to send with HTTP requests. Some services may allow/deny access (or provide different content) based on this.");
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // caching settings
        $fieldset = wire('modules')->get('InputfieldFieldset');
        $fieldset->label = __("Caching");
        $fieldset->icon = "database";
        $fields->add($fieldset);

        // cache max age
        $field = wire('modules')->get('InputfieldSelect');
        $field->name = "cache_max_age";
        $field->label = __("Cache max age");
        $field->description = __("How long should we wait before checking a previously checked link again?");
        $field->addOptions(array(
            '1 DAY' => __("1 day"),
            '1 WEEK' => __("1 week"),
            '2 WEEK' => __("2 weeks"),
            '1 MONTH' => __("1 month"),
        ));
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // clear cache now
        $field = wire('modules')->get('InputfieldCheckbox');
        $field->name = "_clear_cache";
        $field->label = __("Clear cache now");
        if ($cache_count === null) {
            $field->notes = __("Cache status is currently unknown due to a potential database issue.");
        } else {
            $field->notes = sprintf(__("Total of **%d** links are currently cached."), $cache_count);
        }
        $fieldset->add($field);

        // logging settings
        $fieldset = wire('modules')->get('InputfieldFieldset');
        $fieldset->label = __("Logging");
        $fieldset->icon = "file-text";
        $fields->add($fieldset);

        // log level
        $field = wire('modules')->get('InputfieldSelect');
        $field->name = "log_level";
        $field->label = __("Log level");
        $field->description = __("Define how much gets logged by crawler.");
        $field->addOptions(array(
            '0' => '0 ' . __("Nothing (no logging)"),
            '1' => '1 ' . __("Start of each crawl"),
            '2' => '2 ' . __("Crawled pages"),
            '3' => '3 ' . __("Crawled pages and found URLs"),
            '4' => '4 ' . __("Crawled pages, found URLs and recursively checked URLs"),
        ));
        $field->value = $data[$field->name];
        $fieldset->add($field);

        // log rotation
        $field = wire('modules')->get('InputfieldInteger');
        $field->name = "log_rotate";
        $field->label = __("Log rotate");
        $field->value = $data[$field->name];
        $field->description = __("Each log file contains details of one Link Crawler run. This setting defines how many log files for previous runs will be kept.");
        $field->notes = __("By default only the latest log file will be kept; each run replaces the file with new one.");
        $fieldset->add($field);

        // render settings
        $fieldset = wire('modules')->get('InputfieldFieldset');
        $fieldset->label = __("Render");
        $fieldset->icon = "file-text";
        $fields->add($fieldset);

        // render method
        $field = wire('modules')->get('InputfieldSelect');
        $field->name = "render_method";
        $field->label = __("Render method");
        $field->description = __("Define which render method to use. Please note that particularly the exec method may be risky, so avoid making changes here unless you know what you're doing.");
        $exec_attributes = null;
        if (!function_exists('exec')) {
            $field->notes = __("Render method 'exec' is disabled because this system doesn't allow using the exec() command.");
            $exec_attributes = array(
                'disabled' => 'disabled',
            );
        }
        $field->addOption('render_fields', __("Render fields: safe default option, but result doesn't necessarily match final page content"));
        $field->addOption('render_page', __("Render page: provides more realistic results, but may require additional tweaks to template files"));
        $field->addOption('exec', __("Exec: provides realistic results without requiring tweaks to template files, but makes use of exec() method and won't work on all servers"), $exec_attributes);
        $field->value = $data[$field->name];
        $fieldset->add($field);

        return $fields;

    }

    /**
     * Initialization function
     *
     */
    public function init() {
        // fetch page object related to current process
        $process = $this->modules->getModuleID($this->className());
        $this->process_page = $this->pages->get("process=$process");
        // custom handling (sanitizing) for skipped links in module config
        $this->addHookBefore('Modules::saveModuleConfigData', $this, 'sanitizeConfig');
    }

    /**
     * Sanitize config data upon save
     * 
     * Convert URLs separated by newlines to arrays, remove duplicate or empty
     * values (skipped_links and skipped_links_regex), and make sure that the
     * http_host ends with a single slash.
     *
     * @param HookEvent $event
     */
    protected function sanitizeConfig(HookEvent $event) {
        if ($event->arguments[0] != $this->className()) return;
        $arguments = $event->arguments;
        if ($arguments[1]['skipped_links']) {
            $arguments[1]['skipped_links'] = array_unique(array_filter(array_map(
                function($item) {
                    return trim($item);
                },
                preg_split("/\r\n|\n|\r/", $arguments[1]['skipped_links'])
            )));
        }
        if ($arguments[1]['skipped_links_regex']) {
            $arguments[1]['skipped_links_regex'] = array_unique(array_filter(array_map(
                function($item) {
                    return trim($item);
                },
                preg_split("/\r\n|\n|\r/", $arguments[1]['skipped_links_regex'])
            )));
        }
        if ($arguments[1]['http_host']) {
            $arguments[1]['http_host'] = rtrim((string) $arguments[1]['http_host'], "/") . "/";
        }
        if ($arguments[1]['render_method'] == 'exec' && !function_exists('exec')) {
            $arguments[1]['render_method'] = 'render_fields';
        }
        $event->arguments = $arguments;
    }

    /**
     * Executed when page with this process assigned is accessed
     * 
     * @return string
     */
    public function execute() {

        // load scripts and styles
        $this->config->scripts->append($this->config->urls->{$this->className()} . $this->className() . ".js");
        $this->config->styles->append($this->config->urls->{$this->className()} . $this->className() . ".css");

        // inject settings, translations etc.
        $this->config->js($this->className(), array(
            'i18n' => array(
                'commentPrompt' => $this->_("Type in comment text for this link (max 255 characters)"),
                'filterStatus' => $this->_("Filter by status"),
            ),
            'processPage' => $this->process_page->url(),
        ));
        
        // fieldset (tabs)
        $this->modules->get('MarkupAdminDataTable');
        $this->modules->get('JqueryWireTabs');
        $tabs = new InputfieldWrapper();
        $tabs->add($this->buildDashboard());
        $tabs->add($this->buildLinksTab(
            'broken-links',
            $this->_("Broken Links"),
            $this->_("Congratulations, no broken links found!")
        ));
        $tabs->add($this->buildLinksTab(
            'redirects',
            $this->_("Redirects"),
            $this->_("No redirects have been identified yet.")
        ));
        $tabs->add($this->buildLinksTab(
            'skipped-links',
            $this->_("Skipped Links"),
            $this->_("Not a single link has been marked as skipped so far!")
        ));
        if ($this->user->hasPermission('link-checker-run')) {
            $tabs->add($this->buildCheckNow());
        }

        return $tabs->render();
        
    }

    /**
     * Set link comment text
     * 
     * Link is defined by POST param 'links_id' and comment text by POST
     * param 'comment'.
     *
     * @throws WireException if link doesn't exist
     * @return null|string Comment text or null
     */
    public function executeComment() {
        
        // this only applies to POST requests
        if ($_SERVER['REQUEST_METHOD'] !== "POST") return;

        // get and check link
        $links_id = (int) $this->input->post->links_id;
        $stmt = $this->database->prepare("SELECT id FROM " . self::TABLE_LINKS . " WHERE id = :links_id");
        $stmt->bindValue(':links_id', $links_id, PDO::PARAM_INT);
        $stmt->execute();
        $link = $stmt->fetch(PDO::FETCH_ASSOC);
        if (!$link) throw new WireException("Link doesn't exist: $links_id");

        // sanitize and store comment text
        $comment = $this->input->post->comment;
        if (mb_strlen($comment) > 255) $comment = mb_substr($comment, 0, 255);
        $comment = $this->database->escapeStr($comment);
        $stmt = $this->database->prepare("UPDATE " . self::TABLE_LINKS . " SET comment = :comment WHERE id = :links_id");
        $stmt->bindValue(':comment', $comment, PDO::PARAM_STR);
        $stmt->bindValue(':links_id', $links_id, PDO::PARAM_INT);
        $stmt->execute();
        
        // return comment text
        return $comment;

    }

    /**
     * Set link skip status
     * 
     * Link is defined by POST param 'links_id' and skip status by POST
     * param 'skip'.
     *
     * @throws WireException if link doesn't exist
     * @return int skip status after operation
     */
    public function executeSkip() {
        
        // this only applies to POST requests
        if ($_SERVER['REQUEST_METHOD'] !== "POST") return;

        // get and check link
        $links_id = (int) $this->input->post->links_id;
        $stmt = $this->database->prepare("SELECT id FROM " . self::TABLE_LINKS . " WHERE id = :links_id");
        $stmt->bindValue(':links_id', $links_id, PDO::PARAM_INT);
        $stmt->execute();
        $link = $stmt->fetch(PDO::FETCH_ASSOC);
        if (!$link) throw new WireException("Link doesn't exist: $links_id");

        // update skip status
        $skip = $this->input->post->skip ? 1 : 0;
        $stmt = $this->database->prepare("UPDATE " . self::TABLE_LINKS . " SET skip = :skip WHERE id = :links_id");
        $stmt->bindValue(':skip', $skip, PDO::PARAM_STR);
        $stmt->bindValue(':links_id', $links_id, PDO::PARAM_INT);
        $stmt->execute();
        
        // return skip status
        return $skip;

    }

    /**
     * Remove link from list
     * 
     * Link is defined by POST param 'links_id'.
     *
     * @throws WireException if link doesn't exist
     */
    public function executeRemove() {
        
        // this only applies to POST requests
        if ($_SERVER['REQUEST_METHOD'] !== "POST") return;

        // get and check link
        $links_id = (int) $this->input->post->links_id;
        $stmt = $this->database->prepare("SELECT id FROM " . self::TABLE_LINKS . " WHERE id = :links_id");
        $stmt->bindValue(':links_id', $links_id, PDO::PARAM_INT);
        $stmt->execute();
        $link = $stmt->fetch(PDO::FETCH_ASSOC);
        if (!$link) throw new WireException("Link doesn't exist: $links_id");

        // remove link and related row(s) from junction table
        $stmt = $this->database->prepare("
            DELETE links, links_pages 
            FROM " . self::TABLE_LINKS . " links, " . self::TABLE_LINKS_PAGES . " links_pages 
            WHERE links.id = :links_id AND links_pages.links_id = links.id
        ");
        $stmt->bindValue(':links_id', $links_id, PDO::PARAM_INT);
        $stmt->execute();
        
    }

    /**
     * Run link check (LinkCrawler) manually
     * 
     * This is a proof of concept. Much better solution would be triggering
     * LinkCrawler via Cron.
     *
     * @return string Link Crawler output
     * @throws WirePermissionException if user doesn't have 'link-checker-run' permission
     */
    public function executeCheck() {

        // check permissions
        if (!$this->user->hasPermission('link-checker-run')) {
            throw new WirePermissionException();
        }
        
        // load scripts and styles
        $this->config->scripts->append($this->config->urls->{$this->className()} . $this->className() . ".js");
        $this->config->styles->append($this->config->urls->{$this->className()} . $this->className() . ".css");

        // override PHP time limit and disable user abort
        set_time_limit(0);
        ignore_user_abort(true);

        if (!$this->crawler) {
            // load and instantiate Link Crawler
            require_once $this->config->paths->{$this->className()} . "LinkCrawler.php";
            $this->crawler = new LinkCrawler();
        }
        $this->crawler->setConfig('log_level', 4);
        $this->crawler->setConfig('log_on_screen', true);
        if ($selector = $this->input->cookie->link_checker_selector) {
            $this->crawler->setConfig('selector', $selector);
        }

        // run Link Crawler and capture output
        ob_start();
        echo "<pre class='link-crawler-output'>";
        $this->crawler->start();
        $time = wireRelativeTimeStr($this->crawler->stats['time_start']);
        $summary = vsprintf(
            $this->_("Done! %d/%d Pages and %d/%d links checked in %s."),
            array(
                $this->crawler->stats['pages_checked'], 
                $this->crawler->stats['pages'], 
                $this->crawler->stats['links_checked'], 
                $this->crawler->stats['links'], 
                $this->crawler->stats['time_total'],
            )
        );
        echo "</pre>";
        echo "<script type='text/javascript'>"
           . "\$('.link-crawler-output').fadeIn();"
           . "parent.\$('.link-crawler-container').addClass('ready');"
           . "parent.\$('.link-crawler-summary').trigger('finished', ['{$summary}']);"
           . "</script>";
        $out = ob_get_clean();

        return $out;

    }

    /**
     * Run link check (LinkCrawler) for one Page
     * 
     * Note: this isn't currently used by any internal features, but could be
     * useful in the future if, for an example, asynchronous client-side page
     * checking is needed. For this reason it could make sense to output JSON
     * string containing erroneous links (or something similar).
     * 
     * @throws WireException if $page_id is invalid
     * @throws WireException if $page_id doesn't match an existing page
     * @throws WirePermissionException if page isn't editable by current user
     */
    public function executeCheckPage() {
        
        // fetch Page ID from GET param 'page_id' and make sure it's an integer
        $page_id = (int) $this->input->get->page_id;
        if (!$page_id) {
            throw new WireException("Invalid or missing value for GET param 'page_id'");
        }

        // fetch page
        $page = $this->pages->get($page_id);
        if (!$page->id) {
            throw new WireException("Page doesn't exist (id: {$page_id})");
        }
        
        // make sure that the page is editable by current user
        if (!$page->editable()) {
            throw new WirePermissionException();
        }
        
        // load and instantiate Link Crawler (unless already instantiated)
        if (!$this->crawler) {
            require_once $this->config->paths->{$this->className()} . "LinkCrawler.php";
            $this->crawler = new LinkCrawler();
        }

        // start Link Crawler with predefined configuration settings
        $this->crawler->setConfig('selector', 'id=' . $page_id . ', include=all');
        $this->crawler->setConfig('log_level', 4);
        $this->crawler->setConfig('log_on_screen', true);
        $this->crawler->start();
        
        exit;
        
    }

    /**
     * Install routine
     * 
     * When the module is installed, create required database tables and add
     * a new page under the admin area.
     *
     */
    public function install() {

        // create a page for the module
        $page = new Page();
        $page->template = 'admin';
        $page->name = self::PAGE_NAME;
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup, include=all');
        $page->process = $this;
        $page->title = $this->_("Link Checker");
        $page->save();
        $this->message("Created new page: {$page->path}");

        // table containing all found links
        $this->createTable(self::TABLE_LINKS, array(
            'id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY',
            'url VARCHAR(255) NOT NULL UNIQUE',
            'status CHAR(3)',
            'location VARCHAR(255) DEFAULT NULL',
            'skip BOOL DEFAULT FALSE',
            'comment VARCHAR(255) DEFAULT NULL',
            'checked TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP',
            'KEY skip (skip)',
        ));

        // junction table connecting found links with pages
        $this->createTable(self::TABLE_LINKS_PAGES, array(
            'links_id INT UNSIGNED NOT NULL',
            'pages_id INT UNSIGNED NOT NULL',
            'PRIMARY KEY (links_id, pages_id)',
        ));
        
        // table containing history data
        $this->createTable(self::TABLE_HISTORY, array(
            'time_start TIMESTAMP DEFAULT "0000-00-00 00:00:00"',
            'time_end TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP',
            'pages INT UNSIGNED NOT NULL',
            'pages_checked INT UNSIGNED NOT NULL',
            'links INT UNSIGNED NOT NULL',
            'links_checked INT UNSIGNED NOT NULL',
            'unique_links INT UNSIGNED NOT NULL',
            'status VARCHAR(255) NOT NULL',
            'PRIMARY KEY (time_end)',
        ));

    }

    /**
     * When module is uninstalled, drop database tables created during install
     *
     */
    public function uninstall() {

        // drop database tables
        $this->dropTable(self::TABLE_LINKS);
        $this->dropTable(self::TABLE_LINKS_PAGES);
        $this->dropTable(self::TABLE_HISTORY);
        
        // find and delete the page we installed
        $moduleID = $this->modules->getModuleID($this); 
        $page = $this->pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME); 
        
        // delete page
        if ($page->id) {
            $page->delete();
            $this->message("Deleted Page: {$page->path}"); 
        }

    }
    
    /**
     * Return markup for table holding link data
     * 
     * @param string $class class name for table
     * @return string HTML markup for the table, or empty string if no rows found
     * @throws WireException if table isn't known
     */
    public function executeTable() {
        
        // this view is for AJAX only
        if (!$this->config->ajax) {
            throw new Wire404Exception();
        }
        
        // check if a known table
        $table_id = $this->input->get->id;
        if (!isset($this->tables[$table_id])) {
            throw new WireException("Unrecognized table: $table");
        }
        
        // setup new Admin Data Table
        $table = $this->modules->get('MarkupAdminDataTable');
        $table->setEncodeEntities(false);
        $table->setClass($table_id);
        $table->headerRow(array(
            $this->_("URL"),
            $this->_("Pages"),
            $this->_("Status"),
            $this->_("Last checked"),
            $this->_("Skip"),
            $this->_("Comment"),
            '', // placeholder
        ));

        // prepare settings and markup templates
        $comment = "<a class='action edit-comment' data-link='%d' href='#'><i class='fa fa-edit' title='" . $this->_("Edit comment for this link") . "'></i></a>";
        $remove = "<a class='action remove-link' data-link='%d' href='#'><i class='fa fa-trash-o' title='" . $this->_("Remove this link from list") . "'></i></a>";
        $page_limit = 3;
        
        // fetch links from database
        $query = $this->database->query("
            SELECT links.*, GROUP_CONCAT(DISTINCT links_pages.pages_id SEPARATOR '|') as page_ids 
            FROM " . self::TABLE_LINKS . " links 
            LEFT JOIN " . self::TABLE_LINKS_PAGES . " links_pages ON links_pages.links_id = links.id 
            WHERE " . $this->tables[$table_id] . "
            GROUP BY links.id
            ORDER BY links.url
        ");

        $row_count = 0;
        while ($row = $query->fetch(PDO::FETCH_ASSOC)) {

            // increment row count
            ++$row_count;
            
            // string representation of this link itself
            $url_str = $row['url'];
            if ($row['location']) {
                $url_str .= "<br /><small>" . $this->sanitizer->entities($row['location']) . "</small>";
            }
            
            // string representation of pages this link is found from
            $pages_str = "";
            if ($row['page_ids']) {
                $page_ids = $this->sanitizer->text($row['page_ids']);
                $pages = $this->pages->find("id={$page_ids}, limit={$page_limit}, include=all");
                foreach ($pages as $page) {
                    if ($pages_str) $pages_str .= "<br />";
                    $pages_str .= "<a href='{$page->url}' target='_blank'>{$page->url}</a>";
                }
                $total = $pages->getTotal();
                if ($total > $page_limit) {
                    $pages_str .= "<br /><small>(" . sprintf($this->_("+ %d more"), $total-$page_limit) . ")</small>";
                }
            }
            
            // string representation of the status of this link
            $status_title = $this->_("Error checking this link");
            $status_code = "<span title='{$status_title}'>" . $this->_("none") . "</span>";
            $status_str = "<div class='status status-none'>{$status_code}</div>";
            if ($row['status']) {
                $status_title = __("Unknown or non-standard status code");
                $status_type = "unknown";
                if (isset($this->status_codes[$row['status']])) {
                    $status_title = $this->status_codes[$row['status']];
                    $status_type = substr($row['status'], 0, 1) . "xx";
                }
                $status_code = "<span title='{$status_title}'>{$row['status']}</span>";
                $status_str = "<div class='status status-{$status_type} status-{$row['status']}'>{$status_code}</div>";
            }
            
            // construct table row
            $table_row = array(
                $url_str,
                $pages_str,
                $status_str,
                $row['checked'],
                "<input type='checkbox' name='skip' value='{$row['id']}'" . ($row['skip'] ? " checked='checked'" : "") . " />",
                $row['comment'],
                sprintf($comment, $row['id']) . sprintf($remove, $row['id']) 
            );
            
            // add row to table
            $table->has_rows = true;
            $table->row($table_row);
            
        }
        
        return $row_count ? $table->render() : '';
        
    }

    /**
     * Build dashboard widgets
     * 
     * @return InputfieldFieldset
     */
    protected function buildDashboard() {

        // load scripts and styles
        $this->config->scripts->append($this->config->urls->{$this->className()} . "jqplot/jquery.jqplot.min.js");
        $this->config->scripts->append($this->config->urls->{$this->className()} . "jqplot/plugins/jqplot.donutRenderer.min.js");
        $this->config->scripts->append($this->config->urls->{$this->className()} . "jqplot/plugins/jqplot.highlighter.min.js");
        $this->config->scripts->append($this->config->urls->{$this->className()} . "jqplot/plugins/jqplot.cursor.min.js");
        $this->config->scripts->append($this->config->urls->{$this->className()} . "jqplot/plugins/jqplot.dateAxisRenderer.min.js");
        $this->config->scripts->append($this->config->urls->{$this->className()} . $this->className() . ".dashboard.js");
        $this->config->styles->append($this->config->urls->{$this->className()} . "jqplot/jquery.jqplot.min.css");

        // setup fieldset
        $fieldset = new InputfieldFieldset();
        $fieldset->attr('id', 'link-checker-dashboard');
        $fieldset->attr('class', 'link-checker-tab');
        $fieldset->attr('title', $this->_("Dashboard"));
        $fieldset->skipLabel = 2; // Inputfield::skipLabelHeader
        $fieldset->label = "&nbsp;";

        // overview
        $fieldset->add($widget = new InputfieldMarkup);
        $widget->label = $this->_("Overview");
        $json = array(array(), array(), array(), array());
        $query = $this->database->query("
            SELECT time_end, pages, pages_checked, unique_links, links_checked
            FROM " . self::TABLE_HISTORY . "
            ORDER BY time_end
        ");
        $rows = $query->fetchAll(PDO::FETCH_ASSOC);
        $row = array(
            'pages' => 0,
            'pages_checked' => 0,
            'unique_links' => 0,
            'links_checked' => 0,
        );
        foreach ($rows as $row) {
            $json[0][] = array($row['time_end'], (int) $row['pages']);
            $json[1][] = array($row['time_end'], (int) $row['pages_checked']);
            $json[2][] = array($row['time_end'], (int) $row['unique_links']);
            $json[3][] = array($row['time_end'], (int) $row['links_checked']);
        }
        $json = count($rows) ? json_encode($json) : "";
        $widget->value = "<div id='overview'>"
                       . "<div class='help'>" . __("This graph displays the amount of links and pages of the site. Some uncheckable links and pages are to be expected, but if that number gets too big, it might be a sign of an issue.") . "</div>"
                       . "<div class='item unique-links'><strong>{$row['unique_links']}</strong> <small>unique links</small></div>"
                       . "<div class='item checked-links'><strong>{$row['links_checked']}</strong> <small>checked links</small></div>"
                       . "<div class='item checked-pages'><strong>{$row['pages_checked']}</strong> <small>checked pages</small></div>"
                       . "<div class='item total-pages'><strong>{$row['pages']}</strong> <small>total pages</small></div>"
                       . "<div class='plot' id='overview-plot' data-json='{$json}'></div>"
                       . "</div>";
        
        // status breakdown
        $fieldset->add($widget = new InputfieldMarkup);
        $widget->label = $this->_("Status breakdown");
        $status_info = "<i class='fa fa-question-circle' title='" . $this->_("none: unable to read link target, 2xx: OK, 3xx: redirect, 4xx: target not found, 5xx: target has an error") . "'></i>";
        $markup_rows = "<thead><tr>"
                     . "<th class='header'>" . $this->_("Status") . " {$status_info}</th>"
                     . "<th class='header'>" . $this->_("Count") . "</th>"
                     . "<th class='header'>" . $this->_("Percentage") . "</th>"
                     . "</tr></thead>";
        $json = array(
            'none' => array($this->_("none"), 0),
            'unknown' => array($this->_("unknown"), 0),
            '1xx' => array('1xx', 0),
            '2xx' => array('2xx', 0),
            '3xx' => array('3xx', 0),
            '4xx' => array('4xx', 0),
            '5xx' => array('5xx', 0),
        );
        $query = $this->database->query("
            SELECT status, count(*) AS count
            FROM " . self::TABLE_LINKS . "
            GROUP BY status
            ORDER BY status
        ");
        $total = 0;
        $rows = $query->fetchAll(PDO::FETCH_ASSOC);
        foreach ($rows as $row) $total += $row['count'];
        foreach ($rows as $row) {
            if (is_null($row['status'])) {
                $row['status'] = $this->_("none");
                $key = "none";
            } else if (isset($this->status_codes[$row['status']])) {
                $key = $row['status'][0] . "xx";
            } else {
                $key = "unknown";
            }
            $json[$key][1] += $row['count'];
            $percentage = $row['count'] && $total ? round(($row['count']/$total)*100, 2) : 0;
            $status_title = $this->_("Error checking this link");
            if ((int) $row['status']) {
                $status_title = isset($this->status_codes[(int) $row['status']]) ? $this->status_codes[(int) $row['status']] : __("Unknown or non-standard status code");
            }
            $table = '';
            if (!$row['status'] || $row['status'] >= 400) {
                $table = 'broken-links';
            } else if ($row['status'] >= 300 && $row['status'] <= 399 && !in_array($row['status'], array(302, 304, 307))) {
                $table = 'redirects';
            }
            $status = $table ? "<a class='link-checker-table' data-table='{$table}' data-filter='status' href='#status-{$row['status']}'>{$row['status']}</a>" : $row['status'];
            $markup_rows .= "<tr class='c{$key}'>"
                          . "<td title='{$status_title}'><span></span> {$status}</td>"
                          . "<td>{$row['count']}</td>"
                          . "<td>{$percentage}%</td>"
                          . "</tr>";
        }
        $json = count($rows) ? json_encode(array(array_values($json))) : "";
        $widget->value = "<div id='status-breakdown'>"
                       . "<div class='help'>" . __("This graph outlines the health of the links on the site. While broken links and server errors are what you should be most worried about, redirects can cause additional delay for users, and can also imply that a piece of content is about to go away.") . "</div>"
                       . ($json ? "<table class='data'>{$markup_rows}</table>" : "<p>" . $this->_('Not enough data to display this graph.') . "</p>")
                       . "<div class='plot' id='status-breakdown-plot' data-json='{$json}'></div>"
                       . "</div>";

        return $fieldset;
        
    }
    
    /**
     * Build links tab
     * 
     * @param string $id
     * @param string $title
     * @param string $description
     * @return InputfieldMarkup
     */
    protected function buildLinksTab($id, $title, $description) {
        $inputfield = new InputfieldMarkup();
        $inputfield->attr('id', 'link-checker-' . $id);
        $inputfield->attr('class', 'link-checker-tab');
        $inputfield->attr('title', $title);
        $inputfield->description = $description;
        return $inputfield;
    }

    /**
     * Build "check now" tab
     * 
     * @return InputfieldFieldset
     */
    protected function buildCheckNow() {
        
        // load jQuery Core with the Cookie plugin enabled
        $this->wire('modules')->get('JqueryCore')->use('cookie');
        
        // setup fieldset
        $fieldset = new InputfieldFieldset();
        $fieldset->attr('id', 'link-checker-check-now');
        $fieldset->attr('class', 'link-checker-tab');
        $fieldset->attr('title', '<i class="fa fa-refresh" id="link-checker-check-now-icon"></i> ' . $this->_("Check now"));
        $fieldset->skipLabel = 2; // Inputfield::skipLabelHeader
        $fieldset->label = "&nbsp;";

        // info
        $field = new InputfieldMarkup();
        $field->label = $this->_("Running the Link Crawler manually");
        $field->value = "<p>" . $this->_("Please note that once started, the Link Crawler may take a long time to finish and although it attempts to keep running even if you close the browser window or tab, it is recommended that you don't do this until the check is completed. Link Crawler is intended to be ran as a background process (cron job) and the manual option is provided mainly for debugging purposes.") . "</p>"
                      . "<p><em>" . $this->_("This tab contains minimal configuration options; for more, check out the module configuration page.") . "</em></p>";
        $field->icon = "info-circle";
        $fieldset->add($field);

        // selector for finding pages to check for broken links
        if (wire('modules')->isInstalled('InputfieldSelector')) {
            $field = wire('modules')->get('InputfieldSelector');
        } else {
            $field = wire('modules')->get('InputfieldText');
        }
        $field->name = "selector";
        $field->label = __("Selector");
        $field->icon = "search";
        $field->value = $this->{$field->name};
        $field->description = __("Selector for finding pages to check for broken links.");
        $fieldset->add($field);

        // submit button and iframe to contain link crawler results
        $field = new InputfieldMarkup();
        $field->value = "<iframe class='link-crawler-container' seamless data-src='" . $this->process_page->url() . "check?modal=1'></iframe>";
        $field->value .= "<p class='link-crawler-summary'></p>";
        $button = $this->modules->get('InputfieldButton');
        $button->name = "check-now";
        $button->icon = "refresh";
        $button->value = $this->_("Check now");
        $field->value .= $button->render();
        $fieldset->add($field);

        return $fieldset;

    }
    
    /**
     * Helper method for dropping tables
     * 
     * @param string $table Table name
     */
    protected function dropTable($table) {
        $table = $this->database->escapeStr($table);
        $stmt = $this->database->prepare("SHOW TABLES LIKE '$table'");
        $stmt->execute();
        if (count($stmt->fetchAll()) == 1) {
            $this->database->query("DROP TABLE $table");
            $this->message("Dropped Table: $table");
        }
    }

    /**
     * Helper method for creating tables
     *
     * @param string $table Table name
     * @param array $schema Table schema
     * @throws WireDatabaseException if table already exists
     */
    protected function createTable($table, $schema) {
        $table = $this->database->escapeStr($table);
        $stmt = $this->database->prepare("SHOW TABLES LIKE '$table'");
        $stmt->execute();
        if (count($stmt->fetchAll()) == 1) {
            throw new WireDatabaseException("Table $table already exists");
        }
        $sql = "CREATE TABLE $table (";
        $sql .= implode(', ', $schema);
        $sql .= ") ENGINE = MYISAM DEFAULT CHARSET=utf8";
        $this->database->query($sql);
        $this->message("Created Table: $table");
    }

}
